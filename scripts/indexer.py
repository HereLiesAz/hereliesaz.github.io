"""
The Indexer
===========

"The Librarian" of the system.
This script aggregates all the individual processed JSON files into a single `manifest.json`.
It also builds the navigation graph by calculating relationships between artworks.

Functions:
1.  Read all `.json` files in `public/data`.
2.  Calculate visual similarity (Nearest Neighbor) based on Color.
3.  Inject Metadata from `assets/meta`.
4.  Generate the Global Manifest.

Usage:
    python scripts/indexer.py
"""

# Standard Library Imports
import os  # Filesystem access
import json  # JSON parsing/dumping
import math  # Math for distance calculations

# --- CONFIGURATION ---
DATA_DIR = "public/data"
MANIFEST_PATH = "public/manifest.json"

def calculate_distance(c1, c2):
    """
    Calculates the Euclidean distance between two RGB colors.
    Used to determine how "similar" two paintings are.

    Args:
        c1 (list): [r, g, b]
        c2 (list): [r, g, b]

    Returns:
        float: The distance. Lower is more similar.
    """
    # Euclidean formula: sqrt((r1-r2)^2 + (g1-g2)^2 + (b1-b2)^2)
    return math.sqrt(sum((a - b) ** 2 for a, b in zip(c1, c2)))

def main():
    """
    Main execution logic.
    """
    print("[*] Indexing processed art data...")
    
    # Ensure data directory exists. If not, the pipeline is broken.
    if not os.path.exists(DATA_DIR):
        print(f"[!] Data directory {DATA_DIR} not found. Creating empty manifest.")
        # Create a valid but empty manifest to prevent frontend crash.
        with open(MANIFEST_PATH, 'w') as f:
            json.dump({"nodes": []}, f)
        return

    # List all JSON files, excluding the manifest itself if it's in there.
    files = [f for f in os.listdir(DATA_DIR) if f.endswith('.json') and f != 'manifest.json']
    library = []

    # --- PHASE 1: LOAD METADATA ---
    for f in files:
        path = os.path.join(DATA_DIR, f)
        try:
            # Read the JSON generated by Grinder/Pareidolia.
            with open(path, 'r') as json_file:
                data = json.load(json_file)
                
                # Extract relevant fields.
                meta = data.get('meta', {})
                strokes = data.get('strokes', [])
                ghosts = data.get('pareidolia', [])
                
                # Determine "Sweet Spot" (Target View).
                # This determines where the camera looks when visiting this artwork.
                # Default is center (0,0).
                # If "ghosts" (faces) are detected, we center on the first ghost for dramatic effect.
                if len(ghosts) > 0:
                    # Offset to center (0.5, 0.5 is center in UV space).
                    # We subtract 0.5 because the 3D world origin is at the center of the plane.
                    target = [ghosts[0]['x'] - 0.5, ghosts[0]['y'] - 0.5, 0] 
                else:
                    target = [0, 0, 0]

                # Ensure dominant color exists for graph building.
                if 'dominant_color' not in meta:
                    # If not pre-calculated, compute average color of the first 100 strokes.
                    # This is a crude but fast approximation of the image's "vibe".
                    if len(strokes) > 0:
                        sample = strokes[:100]
                        avg_r = sum(s['color'][0] for s in sample) / len(sample)
                        avg_g = sum(s['color'][1] for s in sample) / len(sample)
                        avg_b = sum(s['color'][2] for s in sample) / len(sample)
                        meta['dominant_color'] = [int(avg_r), int(avg_g), int(avg_b)]
                    else:
                        # Fallback for empty/broken data.
                        meta['dominant_color'] = [0, 0, 0]

                # Create the lightweight node entry for the manifest.
                # We do NOT include the strokes here to keep manifest.json small.
                entry = {
                    "id": os.path.splitext(f)[0],      # Use filename as ID
                    "file": f,                         # Filename for fetching details later
                    "resolution": meta.get('resolution', [1024, 1024]),
                    "color": meta['dominant_color'],   # Used for background transition
                    "stroke_count": meta.get('stroke_count', 0),
                    "view_origin": [0, 0, 5],          # Camera starts 5 units back
                    "view_target": target,             # Camera looks at this point
                    "ghost_count": len(ghosts)
                }
                library.append(entry)
                
        except Exception as e:
            # Log error but continue indexing other files.
            print(f"[!] Error reading {f}: {e}")

    # --- PHASE 2: BUILD THE GRAPH ---
    print(f"[*] Building graph for {len(library)} nodes...")
    
    # Calculate neighbors for every node.
    # Complexity: O(n^2). Fine for < 5000 items. If library grows, use a KD-Tree.
    for item in library:
        my_color = item['color']
        distances = []
        
        for potential_match in library:
            # Don't link to self.
            if item['id'] == potential_match['id']:
                continue
            
            # Calculate similarity.
            dist = calculate_distance(my_color, potential_match['color'])

            distances.append({
                "id": potential_match['id'],
                "weight": dist
            })
        
        # Sort by similarity (lowest distance first).
        distances.sort(key=lambda x: x['weight'])
        
        # Link to top 3 matches.
        # This creates the "Path" the user will follow.
        item['neighbors'] = [d['id'] for d in distances[:3]]

    # --- PHASE 3: SAVE MANIFEST ---
    with open(MANIFEST_PATH, 'w') as f:
        # Dump with indentation for human readability.
        json.dump({"nodes": library}, f, indent=2)
    
    print(f"[*] Manifest generated at {MANIFEST_PATH} with {len(library)} items.")

if __name__ == "__main__":
    main()
