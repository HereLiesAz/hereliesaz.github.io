/**
 * INFINITE CANVAS
 * ===============
 * The core rendering component for the artworks.
 * Instead of using simple InstancedMesh, this component manually manages an
 * InstancedBufferGeometry to allow for more complex attribute mapping (Bounds, Depth, Stability).
 *
 * Why InstancedBufferGeometry?
 * Standard InstancedMesh is great for 1000 identical cubes. But our "strokes" are all
 * different colors, sizes, and depths. We need low-level access to push these attributes
 * to the GPU efficiently.
 */

import React, { useRef, useEffect, useMemo, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { AnamorphicShader } from '../shaders/AnamorphicShader';

// Maximum number of strokes per painting to allocate memory for.
// Artworks with more strokes will be truncated. 20k is a safe limit for mobile GPUs.
const MAX_STROKES = 20000; 

// Base path for fetching processed JSON data.
const DATA_PATH = '/data/';

const InfiniteCanvas = ({ activePaintingId, transitionProgress }) => {
  // Reference to the Three.js Mesh object
  const meshRef = useRef();

  // Reference to the ShaderMaterial (to update uniforms)
  const shaderMaterialRef = useRef();

  // State to track if data fetch is complete
  const [dataLoaded, setDataLoaded] = useState(false);
  
  // --- 1. INITIALIZE GEOMETRY (Memory Allocation) ---
  // We create a static geometry buffer once.
  // The attributes are reused for every painting by updating their values.
  // This avoids destroying/creating geometries on every navigation (Memory Churn).
  const geometry = useMemo(() => {
    // InstancedBufferGeometry allows drawing the same geometry multiple times with different data.
    const geo = new THREE.InstancedBufferGeometry();

    // The base shape is a simple square plane (2 triangles).
    const baseGeo = new THREE.PlaneGeometry(1, 1);
    
    // Copy base attributes (position, uv, index) from the quad to our instanced geo.
    geo.setAttribute('position', baseGeo.getAttribute('position'));
    geo.setAttribute('uv', baseGeo.getAttribute('uv'));
    geo.setIndex(baseGeo.getIndex());
    
    // Allocate TypedArrays for Instance Attributes.
    // Float32Array is the native format for WebGL.
    const aColor = new Float32Array(MAX_STROKES * 3);    // RGB (3 floats per stroke)
    const aBounds = new Float32Array(MAX_STROKES * 4);   // X, Y, W, H (Normalized 0-1)
    const aDepth = new Float32Array(MAX_STROKES * 1);    // Z-Depth
    const aStability = new Float32Array(MAX_STROKES * 1);// Stability Score (0-1)

    // Attach attributes to geometry using InstancedBufferAttribute.
    // The second argument is the itemSize (how many floats per instance).
    geo.setAttribute('aColor', new THREE.InstancedBufferAttribute(aColor, 3));
    geo.setAttribute('aBounds', new THREE.InstancedBufferAttribute(aBounds, 4));
    geo.setAttribute('aDepth', new THREE.InstancedBufferAttribute(aDepth, 1));
    geo.setAttribute('aStability', new THREE.InstancedBufferAttribute(aStability, 1));
    
    return geo;
  }, []); // Empty dependency array = Create once on mount

  // --- 2. DATA LOADING & POPULATION ---
  // Runs whenever the activePaintingId changes.
  useEffect(() => {
    if (!activePaintingId) return;

    const loadPainting = async (id) => {
      try {
        // Fetch the JSON generated by the Grinder.
        const response = await fetch(`${DATA_PATH}${id}.json`);
        if (!response.ok) throw new Error(`Status ${response.status}`);
        
        const data = await response.json();
        
        // Validation: Ensure valid data structure
        if (!data || !data.strokes || !Array.isArray(data.strokes)) {
            console.warn(`[Canvas] Painting ${id} invalid or empty.`);
            return;
        }

        // Clamp count to our pre-allocated buffer size.
        const count = Math.min(data.strokes.length, MAX_STROKES);

        // Get references to the attribute buffers
        const colAttr = geometry.attributes.aColor;
        const boundsAttr = geometry.attributes.aBounds;
        const depthAttr = geometry.attributes.aDepth;
        const stabAttr = geometry.attributes.aStability;

        const width = data.meta?.resolution?.[0] || 1024;
        const height = data.meta?.resolution?.[1] || 1024;

        // Populate Buffers
        for (let i = 0; i < count; i++) {
          const s = data.strokes[i];

          // Color: Normalize 0-255 -> 0.0-1.0
          colAttr.setXYZ(i, s.color[0]/255, s.color[1]/255, s.color[2]/255);
          
          // Bounds: Normalize pixel coords to 0.0-1.0 UV space.
          // Note: Y is flipped (1.0 - y) because WebGL 0,0 is bottom-left, images are top-left.
          const nX = s.bbox[0] / width;
          const nY = 1.0 - (s.bbox[1] / height);
          const nW = s.bbox[2] / width;
          const nH = s.bbox[3] / height;
          
          boundsAttr.setXYZW(i, nX, nY, nW, nH);

          // Depth & Stability
          depthAttr.setX(i, s.z);
          stabAttr.setX(i, s.stability || 0.5);
        }

        // Mark attributes as needing update for the GPU.
        // If we don't set this, Three.js won't re-upload the data.
        colAttr.needsUpdate = true;
        boundsAttr.needsUpdate = true;
        depthAttr.needsUpdate = true;
        stabAttr.needsUpdate = true;
        
        // Update the instance count so we only draw valid strokes.
        geometry.instanceCount = count;

        setDataLoaded(true);
        
      } catch (e) {
        console.error("Failed to load painting:", e);
      }
    };

    loadPainting(activePaintingId);
  }, [activePaintingId, geometry]);

  // --- 3. ANIMATION LOOP ---
  // Runs every frame.
  useFrame((state) => {
    if (!shaderMaterialRef.current) return;
    
    // Update Time Uniform (for noise animation)
    shaderMaterialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
    
    // Calculate Chaos Level based on Transition Progress.
    // 'Chaos' is the magnitude of the explosion effect.
    // - When progress is 0 (At painting A): chaos = 0
    // - When progress is 0.5 (Mid-flight): chaos = 1 (Max explosion)
    // - When progress is 1 (At painting B): chaos = 0
    let chaos = 0;
    if (transitionProgress < 0.5) chaos = transitionProgress * 2.0; // 0 -> 0.5 becomes 0 -> 1
    else chaos = (1.0 - transitionProgress) * 2.0; // 0.5 -> 1 becomes 1 -> 0
    
    // Smoothly lerp chaos value for fluid transitions.
    // This prevents sudden snaps if frame rate drops.
    shaderMaterialRef.current.uniforms.uChaos.value = THREE.MathUtils.lerp(
      shaderMaterialRef.current.uniforms.uChaos.value,
      chaos,
      0.1
    );
  });

  // --- 4. RENDER ---
  return (
    // The Mesh holds the Geometry and Material together.
    // frustumCulled=false: We disable CPU culling because our vertex shader displaces points wildly.
    // If we kept it on, strokes might disappear when their original bounding box leaves the screen.
    <mesh ref={meshRef} geometry={geometry} frustumCulled={false}>
      {AnamorphicShader ? (
        <shaderMaterial
            ref={shaderMaterialRef}
            attach="material"
            args={[AnamorphicShader]} // Use our custom shader definition
            transparent={true}       // Enable Alpha blending
            depthWrite={false}       // Disable writing to Depth Buffer (Painter's Algorithmish)
            blending={THREE.NormalBlending}
        />
      ) : (
        // Fallback for debugging if shader is missing
        <meshBasicMaterial color="red" wireframe />
      )}
    </mesh>
  );
};

export default InfiniteCanvas;
