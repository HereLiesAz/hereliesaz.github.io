name: Jules-Proof Project Backup

on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Justification for this digital hoarding'
        required: false
        default: 'Paranoia'

jobs:
  backup:
    runs-on: windows-latest
    name: Execute Backup Protocol

    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: Run Backup Script
        id: run_backup
        # SWITCHING TO PWSH (Core) for better UTF-8 handling
        shell: pwsh
        run: |
          # --- Embedding User Script ---
          
          # Configuration
          $ScriptName = "backup.ps1"
          $BackupPrefix = "project_backup"
          $Timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          $PSScriptRoot = Get-Location
          $BackupFile = Join-Path -Path $PSScriptRoot -ChildPath "${BackupPrefix}_full_${Timestamp}.txt"
          $FileSizeLimit = 500KB

          # Directories to exclude.
          $excludeDirs = @(
              ".git",
              ".gradle",
              ".idea",
              ".vscode",
              ".cxx",
              "build",
              "captures",
              "dist",
              "node_modules",
              "out",
              "coverage",
              ".next",
              "bin",
              "obj",
              "__pycache__",
              "libs",
              "opencv*",
              "*/absl",
              "*/ceres-solver/include",
              "*/ceres-solver/data",
              "*/ceres-solver/ci",
              "*/ceres-solver/internal",
              "*/ceres-solver/include",
              "*/ceres-solver/examples",
              "*/ceres-solver/config",
              "*/eigen/lapack",
              "*/eigen/blas",
              "*/eigen/debug",
              "*/eigen/unsupported",
              "*/eigen/Eigen",
              "*/eigen/test",
              "*/eigen/demos",
              "*/eigen/scripts",
              "*/eigen/failtest",
              "*/eigen/cmake",
              "*/eigen/bench",
              "*/eigen/doc",
              "*/libs/"
          )

          # File patterns to exclude.
          $excludeFiles = @(
              $ScriptName,
              "${BackupPrefix}*.txt",
              "local.properties",
              "gradlew",
              "gradlew.bat",
              "package-lock.json",
              "yarn.lock",
              "pnpm-lock.yaml",
              "*.iml",
              "*.log",
              "*.map",
              "*.so", "lib*.so", "*.dylib", "*.dll", "*.obj", "*.o", "*.a", "*.lib",
              "*.apk", "*.aar", "*.dex", "*.class",
              "*.exe", "*.bin", "*.msi",
              "*.zip", "*.tar", "*.gz", "*.rar", "*.7z", "*.jar",
              "*.png", "*.jpg", "*.jpeg", "*.gif", "*.svg", "*.ico", "*.webp", "*.bmp", "*.tiff",
              "*.mp3", "*.mp4", "*.wav", "*.avi", "*.mov", "*.mkv",
              "*.ttf", "*.otf", "*.woff", "*.woff2", "*.eot",
              ".DS_Store", "Thumbs.db"
          )

          # --- Helper: Check if Item should be Excluded ---
          function Test-IsExcluded {
              param (
                  [System.IO.FileInfo]$Item,
                  [string]$RootPath
              )

              # 1. Name Check
              foreach ($pattern in $excludeFiles) {
                  if ($Item.Name -like $pattern) { return $true }
              }

              # 2. Path Check (Directories)
              $normalizedPath = $Item.FullName.Replace($RootPath, "").TrimStart("\/")
              $pathParts = $normalizedPath -split "[\\/]"

              foreach ($part in $pathParts) {
                  if ($excludeDirs -contains $part) { return $true }
              }

              return $false
          }

          # --- .gitignore Assimilation ---
          if (Test-Path "$PSScriptRoot\.gitignore") {
              Write-Host "Parsing .gitignore..." -ForegroundColor Cyan
              $gitIgnoreContent = Get-Content "$PSScriptRoot\.gitignore"
              foreach ($line in $gitIgnoreContent) {
                  if ([string]::IsNullOrWhiteSpace($line) -or $line.StartsWith("#") -or $line.StartsWith("!")) { continue }
                  $cleanLine = $line.Trim().Replace('/', [System.IO.Path]::DirectorySeparatorChar)

                  if ($cleanLine.EndsWith([System.IO.Path]::DirectorySeparatorChar)) {
                      $dirName = $cleanLine.TrimEnd([System.IO.Path]::DirectorySeparatorChar)
                      if ($excludeDirs -notcontains $dirName) { $excludeDirs += $dirName }
                  } else {
                      if ($excludeFiles -notcontains $cleanLine) { $excludeFiles += $cleanLine }
                  }
              }
          }

          # --- .aiexclude Assimilation ---
          if (Test-Path "$PSScriptRoot\.aiexclude") {
              Write-Host "Parsing .aiexclude..." -ForegroundColor Magenta
              $aiExcludeContent = Get-Content "$PSScriptRoot\.aiexclude"
              foreach ($line in $aiExcludeContent) {
                  if ([string]::IsNullOrWhiteSpace($line) -or $line.StartsWith("#") -or $line.StartsWith("!")) { continue }
                  $cleanLine = $line.Trim().Replace('/', [System.IO.Path]::DirectorySeparatorChar)

                  if ($cleanLine.EndsWith([System.IO.Path]::DirectorySeparatorChar)) {
                      $dirName = $cleanLine.TrimEnd([System.IO.Path]::DirectorySeparatorChar)
                      if ($excludeDirs -notcontains $dirName) { $excludeDirs += $dirName }
                  } else {
                      if ($excludeFiles -notcontains $cleanLine) { $excludeFiles += $cleanLine }
                  }
              }
          }

          # --- Function: Generate File Tree ---
          function Write-FileTree {
              param (
                  [string]$Path,
                  [string]$Indent,
                  [bool]$IsLast,
                  [string]$RootPath
              )

              # Define Tree Characters via Hex to bypass YAML/Runner encoding issues
              # L-Shape
              $g_last   = "$([char]0x2514)$([char]0x2500)$([char]0x2500) "
              # T-Shape
              $g_branch = "$([char]0x251C)$([char]0x2500)$([char]0x2500) "
              # Vertical Line
              $g_vert   = "$([char]0x2502)   "
              $g_empty  = "    "

              $items = Get-ChildItem -Path $Path -Force | Where-Object {
                  $isExcluded = $false
                  if ($_.PSIsContainer) {
                      if ($excludeDirs -contains $_.Name) { $isExcluded = $true }
                  } else {
                      foreach ($pattern in $excludeFiles) {
                          if ($_.Name -like $pattern) { $isExcluded = $true; break }
                      }
                  }
                  return -not $isExcluded
              }

              $count = $items.Count
              $i = 0

              foreach ($item in $items) {
                  $i++
                  $isLastItem = ($i -eq $count)
                  
                  if ($isLastItem) { $marker = $g_last } else { $marker = $g_branch }
                  
                  $line = "$Indent$marker$($item.Name)"
                  Add-Content -Path $BackupFile -Value $line

                  if ($item.PSIsContainer) {
                      if ($isLastItem) { $nextIndent = $g_empty } else { $nextIndent = $g_vert }
                      $newIndent = $Indent + $nextIndent
                      Write-FileTree -Path $item.FullName -Indent $newIndent -IsLast $isLastItem -RootPath $RootPath
                  }
              }
          }

          # --- Execution ---
          # Force Output Encoding to UTF8
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8

          Write-Host "Initializing Backup..." -ForegroundColor Green
          Write-Host "Target: $BackupFile"

          Set-Content -Path $BackupFile -Value "# PROJECT BACKUP: $Timestamp"
          Add-Content -Path $BackupFile -Value "# NOTE: Binary files and 'libs' directory excluded."
          Add-Content -Path $BackupFile -Value "`n# --- PROJECT STRUCTURE ---"

          Write-Host "Generating File Tree..." -ForegroundColor Cyan
          Write-FileTree -Path $PSScriptRoot -Indent "" -IsLast $true -RootPath $PSScriptRoot

          Add-Content -Path $BackupFile -Value "`n# --- FILE CONTENTS ---"
          Write-Host "Backing up content..." -ForegroundColor Cyan

          Get-ChildItem -Path $PSScriptRoot -Recurse -File | ForEach-Object {
              $file = $_
              if (Test-IsExcluded -Item $file -RootPath $PSScriptRoot) { return }

              if ($file.Length -gt $FileSizeLimit) {
                  Add-Content -Path $BackupFile -Value "`n## FILE: $($file.FullName.Replace($PSScriptRoot, '.')) [SKIPPED - TOO LARGE]"
                  return
              }

              try {
                  $content = Get-Content $file.FullName -Raw
              }
              catch {
                  Write-Warning "Locked: $($file.Name)"
                  return
              }

              if (-not [string]::IsNullOrWhiteSpace($content)) {
                  if ($content.Contains("`0")) { return }
                  $relativePath = $file.FullName.Replace($PSScriptRoot, '.')
                  Write-Host "  + $relativePath"
                  Add-Content -Path $BackupFile -Value "`n## FILE: $relativePath"
                  Add-Content -Path $BackupFile -Value $content.Trim()
              }
          }
          
          # Export path for artifact upload
          echo "BACKUP_PATH=$BackupFile" >> $env:GITHUB_ENV
          Write-Host "âœ… Backup complete." -ForegroundColor Green

      - name: Upload Artifact
        uses: actions/upload-artifact@v
